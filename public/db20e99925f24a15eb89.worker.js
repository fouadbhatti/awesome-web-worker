/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/babel-loader/lib/index.js!./app/compute.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./app/compute.worker.js":
/*!***************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./app/compute.worker.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var comlinkjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! comlinkjs */ \"./node_modules/comlinkjs/comlink.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar insertionSort =\n/*#__PURE__*/\nfunction () {\n  function insertionSort() {\n    _classCallCheck(this, insertionSort);\n\n    this.resetSort();\n    this.pauseExecution = false;\n    this.sample = this.createSample(100000);\n  }\n\n  _createClass(insertionSort, [{\n    key: \"createSample\",\n    value: function createSample(length) {\n      return Array(length).fill().map(function () {\n        return Math.round(Math.random() * length);\n      });\n    }\n  }, {\n    key: \"resetSort\",\n    value: function resetSort() {\n      this.state = {\n        i: 1,\n        j: null,\n        value: null\n      };\n    }\n  }, {\n    key: \"pauseSort\",\n    value: function pauseSort() {\n      this.pauseExecution = true;\n      return 'sort paused';\n    }\n  }, {\n    key: \"addToSort\",\n    value: function addToSort(number) {\n      this.sample.push(number);\n      return {\n        message: 'Added to sample'\n      };\n    }\n  }, {\n    key: \"nonBlockingLoop\",\n    value: function nonBlockingLoop(n, callback) {\n      var _this = this;\n\n      var loop = function loop() {\n        if (_this.state.i < n) {\n          _this.sortInternal();\n\n          if (_this.pauseExecution) {\n            callback(_this.state.i, false);\n            return true;\n          }\n\n          _this.state.i++;\n          (self.requestAnimationFrame || self.setTimeout)(loop);\n        } else {\n          callback(_this.state.i, true);\n        }\n      };\n\n      loop();\n    }\n  }, {\n    key: \"sortInternal\",\n    value: function sortInternal() {\n      this.state.value = this.sample[this.state.i];\n      this.state.j = this.state.i - 1;\n\n      while (this.state.j >= 0 && this.sample[this.state.j] > this.state.value) {\n        this.sample[this.state.j + 1] = this.sample[this.state.j];\n        this.state.j = this.state.j - 1;\n      }\n\n      this.sample[this.state.j + 1] = this.state.value;\n    }\n  }, {\n    key: \"sort\",\n    value: function sort(callback) {\n      var _this2 = this;\n\n      this.pauseExecution = false;\n      this.nonBlockingLoop(this.sample.length, function (currentI, done) {\n        if (done) {\n          callback({\n            message: 'Array Sorted',\n            payload: _this2.sample\n          });\n        } else {\n          callback({\n            message: 'Sorting paused',\n            payload: _this2.sample\n          });\n        }\n      });\n    }\n  }]);\n\n  return insertionSort;\n}();\n\ncomlinkjs__WEBPACK_IMPORTED_MODULE_0__[\"expose\"](insertionSort, self);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL2FwcC9jb21wdXRlLndvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC9jb21wdXRlLndvcmtlci5qcz83ZmU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIENvbWxpbmsgZnJvbSAnY29tbGlua2pzJztcblxuY2xhc3MgaW5zZXJ0aW9uU29ydCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVzZXRTb3J0KCk7XG4gICAgdGhpcy5wYXVzZUV4ZWN1dGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuc2FtcGxlID0gdGhpcy5jcmVhdGVTYW1wbGUoMTAwMDAwKTtcbiAgfVxuXG4gIGNyZWF0ZVNhbXBsZShsZW5ndGgpIHtcbiAgICByZXR1cm4gQXJyYXkobGVuZ3RoKS5maWxsKCkubWFwKCgpID0+IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCkpO1xuICB9XG5cbiAgcmVzZXRTb3J0KCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpOiAxLFxuICAgICAgajogbnVsbCxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgIH07XG4gIH1cblxuICBwYXVzZVNvcnQoKSB7XG4gICAgdGhpcy5wYXVzZUV4ZWN1dGlvbiA9IHRydWU7XG4gICAgcmV0dXJuICdzb3J0IHBhdXNlZCc7XG4gIH1cblxuICBhZGRUb1NvcnQobnVtYmVyKSB7XG4gICAgdGhpcy5zYW1wbGUucHVzaChudW1iZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiAnQWRkZWQgdG8gc2FtcGxlJ1xuICAgIH1cbiAgfVxuXG5cbiAgbm9uQmxvY2tpbmdMb29wKG4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbG9vcCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmkgPCBuKSB7XG4gICAgICAgIHRoaXMuc29ydEludGVybmFsKCk7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlRXhlY3V0aW9uKSB7XG4gICAgICAgICAgY2FsbGJhY2sodGhpcy5zdGF0ZS5pLCBmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5pKys7XG4gICAgICAgIChzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBzZWxmLnNldFRpbWVvdXQpKGxvb3ApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMuc3RhdGUuaSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxvb3AoKTtcbiAgfVxuXG4gIHNvcnRJbnRlcm5hbCgpIHtcbiAgICB0aGlzLnN0YXRlLnZhbHVlID0gdGhpcy5zYW1wbGVbdGhpcy5zdGF0ZS5pXTtcbiAgICB0aGlzLnN0YXRlLmogPSB0aGlzLnN0YXRlLmkgLSAxO1xuXG4gICAgd2hpbGUodGhpcy5zdGF0ZS5qID49IDAgJiYgdGhpcy5zYW1wbGVbdGhpcy5zdGF0ZS5qXSA+IHRoaXMuc3RhdGUudmFsdWUpIHtcbiAgICAgIHRoaXMuc2FtcGxlW3RoaXMuc3RhdGUuaiArIDFdID0gdGhpcy5zYW1wbGVbdGhpcy5zdGF0ZS5qXTtcbiAgICAgIHRoaXMuc3RhdGUuaiA9IHRoaXMuc3RhdGUuaiAtIDE7XG4gICAgfVxuXG4gICAgdGhpcy5zYW1wbGVbdGhpcy5zdGF0ZS5qICsgMV0gPSB0aGlzLnN0YXRlLnZhbHVlO1xuICB9XG5cbiAgc29ydChjYWxsYmFjaykge1xuICAgIHRoaXMucGF1c2VFeGVjdXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLm5vbkJsb2NraW5nTG9vcCh0aGlzLnNhbXBsZS5sZW5ndGgsIChjdXJyZW50SSwgZG9uZSkgPT4ge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soeyBtZXNzYWdlOiAnQXJyYXkgU29ydGVkJywgcGF5bG9hZDogdGhpcy5zYW1wbGUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh7IG1lc3NhZ2U6ICdTb3J0aW5nIHBhdXNlZCcsIHBheWxvYWQ6IHRoaXMuc2FtcGxlIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbkNvbWxpbmsuZXhwb3NlKGluc2VydGlvblNvcnQsIHNlbGYpOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js!./app/compute.worker.js\n");

/***/ }),

/***/ "./node_modules/comlinkjs/comlink.js":
/*!*******************************************!*\
  !*** ./node_modules/comlinkjs/comlink.js ***!
  \*******************************************/
/*! exports provided: transferHandlers, proxy, proxyValue, expose */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transferHandlers\", function() { return transferHandlers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"proxy\", function() { return proxy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"proxyValue\", function() { return proxyValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expose\", function() { return expose; });\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst TRANSFERABLE_TYPES = [\"ArrayBuffer\", \"MessagePort\", \"OffscreenCanvas\"]\n    .filter(f => f in self)\n    .map(f => self[f]);\nconst uid = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\nconst proxyValueSymbol = Symbol(\"proxyValue\");\nconst throwSymbol = Symbol(\"throw\");\nconst proxyTransferHandler = {\n    canHandle: (obj) => obj && obj[proxyValueSymbol],\n    serialize: (obj) => {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return port2;\n    },\n    deserialize: (obj) => {\n        return proxy(obj);\n    }\n};\nconst throwTransferHandler = {\n    canHandle: (obj) => obj && obj[throwSymbol],\n    serialize: (obj) => {\n        const message = obj && obj.message;\n        const stack = obj && obj.stack;\n        return Object.assign({}, obj, { message, stack });\n    },\n    deserialize: (obj) => {\n        throw Object.assign(Error(), obj);\n    }\n};\nconst transferHandlers = new Map([\n    [\"PROXY\", proxyTransferHandler],\n    [\"THROW\", throwTransferHandler]\n]);\nlet pingPongMessageCounter = 0;\nfunction proxy(endpoint, target) {\n    if (isWindow(endpoint))\n        endpoint = windowEndpoint(endpoint);\n    if (!isEndpoint(endpoint))\n        throw Error(\"endpoint does not have all of addEventListener, removeEventListener and postMessage defined\");\n    activateEndpoint(endpoint);\n    return cbProxy(async (irequest) => {\n        let args = [];\n        if (irequest.type === \"APPLY\" || irequest.type === \"CONSTRUCT\")\n            args = irequest.argumentsList.map(wrapValue);\n        const response = await pingPongMessage(endpoint, Object.assign({}, irequest, { argumentsList: args }), transferableProperties(args));\n        const result = response.data;\n        return unwrapValue(result.value);\n    }, [], target);\n}\nfunction proxyValue(obj) {\n    obj[proxyValueSymbol] = true;\n    return obj;\n}\nfunction expose(rootObj, endpoint) {\n    if (isWindow(endpoint))\n        endpoint = windowEndpoint(endpoint);\n    if (!isEndpoint(endpoint))\n        throw Error(\"endpoint does not have all of addEventListener, removeEventListener and postMessage defined\");\n    activateEndpoint(endpoint);\n    attachMessageHandler(endpoint, async function (event) {\n        if (!event.data.id || !event.data.callPath)\n            return;\n        const irequest = event.data;\n        let that = await irequest.callPath\n            .slice(0, -1)\n            .reduce((obj, propName) => obj[propName], rootObj);\n        let obj = await irequest.callPath.reduce((obj, propName) => obj[propName], rootObj);\n        let iresult = obj;\n        let args = [];\n        if (irequest.type === \"APPLY\" || irequest.type === \"CONSTRUCT\")\n            args = irequest.argumentsList.map(unwrapValue);\n        if (irequest.type === \"APPLY\") {\n            try {\n                iresult = await obj.apply(that, args);\n            }\n            catch (e) {\n                iresult = e;\n                iresult[throwSymbol] = true;\n            }\n        }\n        if (irequest.type === \"CONSTRUCT\") {\n            try {\n                iresult = new obj(...args); // eslint-disable-line new-cap\n                iresult = proxyValue(iresult);\n            }\n            catch (e) {\n                iresult = e;\n                iresult[throwSymbol] = true;\n            }\n        }\n        if (irequest.type === \"SET\") {\n            obj[irequest.property] = irequest.value;\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            iresult = true;\n        }\n        iresult = makeInvocationResult(iresult);\n        iresult.id = irequest.id;\n        return endpoint.postMessage(iresult, transferableProperties([iresult]));\n    });\n}\nfunction wrapValue(arg) {\n    // Is arg itself handled by a TransferHandler?\n    for (const [key, transferHandler] of transferHandlers) {\n        if (transferHandler.canHandle(arg)) {\n            return {\n                type: key,\n                value: transferHandler.serialize(arg)\n            };\n        }\n    }\n    // If not, traverse the entire object and find handled values.\n    let wrappedChildren = [];\n    for (const item of iterateAllProperties(arg)) {\n        for (const [key, transferHandler] of transferHandlers) {\n            if (transferHandler.canHandle(item.value)) {\n                wrappedChildren.push({\n                    path: item.path,\n                    wrappedValue: {\n                        type: key,\n                        value: transferHandler.serialize(item.value)\n                    }\n                });\n            }\n        }\n    }\n    for (const wrappedChild of wrappedChildren) {\n        const container = wrappedChild.path\n            .slice(0, -1)\n            .reduce((obj, key) => obj[key], arg);\n        container[wrappedChild.path[wrappedChild.path.length - 1]] = null;\n    }\n    return {\n        type: \"RAW\",\n        value: arg,\n        wrappedChildren\n    };\n}\nfunction unwrapValue(arg) {\n    if (transferHandlers.has(arg.type)) {\n        const transferHandler = transferHandlers.get(arg.type);\n        return transferHandler.deserialize(arg.value);\n    }\n    else if (isRawWrappedValue(arg)) {\n        for (const wrappedChildValue of arg.wrappedChildren || []) {\n            if (!transferHandlers.has(wrappedChildValue.wrappedValue.type))\n                throw Error(`Unknown value type \"${arg.type}\" at ${wrappedChildValue.path.join(\".\")}`);\n            const transferHandler = transferHandlers.get(wrappedChildValue.wrappedValue.type);\n            const newValue = transferHandler.deserialize(wrappedChildValue.wrappedValue.value);\n            replaceValueInObjectAtPath(arg.value, wrappedChildValue.path, newValue);\n        }\n        return arg.value;\n    }\n    else {\n        throw Error(`Unknown value type \"${arg.type}\"`);\n    }\n}\nfunction replaceValueInObjectAtPath(obj, path, newVal) {\n    const lastKey = path.slice(-1)[0];\n    const lastObj = path\n        .slice(0, -1)\n        .reduce((obj, key) => obj[key], obj);\n    lastObj[lastKey] = newVal;\n}\nfunction isRawWrappedValue(arg) {\n    return arg.type === \"RAW\";\n}\nfunction windowEndpoint(w) {\n    if (self.constructor.name !== \"Window\")\n        throw Error(\"self is not a window\");\n    return {\n        addEventListener: self.addEventListener.bind(self),\n        removeEventListener: self.removeEventListener.bind(self),\n        postMessage: (msg, transfer) => w.postMessage(msg, \"*\", transfer)\n    };\n}\nfunction isEndpoint(endpoint) {\n    return (\"addEventListener\" in endpoint &&\n        \"removeEventListener\" in endpoint &&\n        \"postMessage\" in endpoint);\n}\nfunction activateEndpoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.start();\n}\nfunction attachMessageHandler(endpoint, f) {\n    // Checking all possible types of `endpoint` manually satisfies TypeScript’s\n    // type checker. Not sure why the inference is failing here. Since it’s\n    // unnecessary code I’m going to resort to `any` for now.\n    // if(isWorker(endpoint))\n    //   endpoint.addEventListener('message', f);\n    // if(isMessagePort(endpoint))\n    //   endpoint.addEventListener('message', f);\n    // if(isOtherWindow(endpoint))\n    //   endpoint.addEventListener('message', f);\n    endpoint.addEventListener(\"message\", f);\n}\nfunction detachMessageHandler(endpoint, f) {\n    // Same as above.\n    endpoint.removeEventListener(\"message\", f);\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction isWindow(endpoint) {\n    // TODO: This doesn’t work on cross-origin iframes.\n    // return endpoint.constructor.name === 'Window';\n    return [\"window\", \"length\", \"location\", \"parent\", \"opener\"].every(prop => prop in endpoint);\n}\n/**\n * `pingPongMessage` sends a `postMessage` and waits for a reply. Replies are\n * identified by a unique id that is attached to the payload.\n */\nfunction pingPongMessage(endpoint, msg, transferables) {\n    const id = `${uid}-${pingPongMessageCounter++}`;\n    return new Promise(resolve => {\n        attachMessageHandler(endpoint, function handler(event) {\n            if (event.data.id !== id)\n                return;\n            detachMessageHandler(endpoint, handler);\n            resolve(event);\n        });\n        // Copy msg and add `id` property\n        msg = Object.assign({}, msg, { id });\n        endpoint.postMessage(msg, transferables);\n    });\n}\nfunction cbProxy(cb, callPath = [], target = function () { }) {\n    return new Proxy(target, {\n        construct(_target, argumentsList, proxy) {\n            return cb({\n                type: \"CONSTRUCT\",\n                callPath,\n                argumentsList\n            });\n        },\n        apply(_target, _thisArg, argumentsList) {\n            // We use `bind` as an indicator to have a remote function bound locally.\n            // The actual target for `bind()` is currently ignored.\n            if (callPath[callPath.length - 1] === \"bind\")\n                return cbProxy(cb, callPath.slice(0, -1));\n            return cb({\n                type: \"APPLY\",\n                callPath,\n                argumentsList\n            });\n        },\n        get(_target, property, proxy) {\n            if (property === \"then\" && callPath.length === 0) {\n                return { then: () => proxy };\n            }\n            else if (property === \"then\") {\n                const r = cb({\n                    type: \"GET\",\n                    callPath\n                });\n                return Promise.resolve(r).then.bind(r);\n            }\n            else {\n                return cbProxy(cb, callPath.concat(property), _target[property]);\n            }\n        },\n        set(_target, property, value, _proxy) {\n            return cb({\n                type: \"SET\",\n                callPath,\n                property,\n                value\n            });\n        }\n    });\n}\nfunction isTransferable(thing) {\n    return TRANSFERABLE_TYPES.some(type => thing instanceof type);\n}\nfunction* iterateAllProperties(value, path = [], visited = null) {\n    if (!value)\n        return;\n    if (!visited)\n        visited = new WeakSet();\n    if (visited.has(value))\n        return;\n    if (typeof value === \"string\")\n        return;\n    if (typeof value === \"object\")\n        visited.add(value);\n    if (ArrayBuffer.isView(value))\n        return;\n    yield { value, path };\n    const keys = Object.keys(value);\n    for (const key of keys)\n        yield* iterateAllProperties(value[key], [...path, key], visited);\n}\nfunction transferableProperties(obj) {\n    const r = [];\n    for (const prop of iterateAllProperties(obj)) {\n        if (isTransferable(prop.value))\n            r.push(prop.value);\n    }\n    return r;\n}\nfunction makeInvocationResult(obj) {\n    for (const [type, transferHandler] of transferHandlers) {\n        if (transferHandler.canHandle(obj)) {\n            const value = transferHandler.serialize(obj);\n            return {\n                value: { type, value }\n            };\n        }\n    }\n    return {\n        value: {\n            type: \"RAW\",\n            value: obj\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGlua2pzL2NvbWxpbmsuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tbGlua2pzL2NvbWxpbmsuanM/YmI5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBUUkFOU0ZFUkFCTEVfVFlQRVMgPSBbXCJBcnJheUJ1ZmZlclwiLCBcIk1lc3NhZ2VQb3J0XCIsIFwiT2Zmc2NyZWVuQ2FudmFzXCJdXG4gICAgLmZpbHRlcihmID0+IGYgaW4gc2VsZilcbiAgICAubWFwKGYgPT4gc2VsZltmXSk7XG5jb25zdCB1aWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG5jb25zdCBwcm94eVZhbHVlU3ltYm9sID0gU3ltYm9sKFwicHJveHlWYWx1ZVwiKTtcbmNvbnN0IHRocm93U3ltYm9sID0gU3ltYm9sKFwidGhyb3dcIik7XG5jb25zdCBwcm94eVRyYW5zZmVySGFuZGxlciA9IHtcbiAgICBjYW5IYW5kbGU6IChvYmopID0+IG9iaiAmJiBvYmpbcHJveHlWYWx1ZVN5bWJvbF0sXG4gICAgc2VyaWFsaXplOiAob2JqKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDEpO1xuICAgICAgICByZXR1cm4gcG9ydDI7XG4gICAgfSxcbiAgICBkZXNlcmlhbGl6ZTogKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4gcHJveHkob2JqKTtcbiAgICB9XG59O1xuY29uc3QgdGhyb3dUcmFuc2ZlckhhbmRsZXIgPSB7XG4gICAgY2FuSGFuZGxlOiAob2JqKSA9PiBvYmogJiYgb2JqW3Rocm93U3ltYm9sXSxcbiAgICBzZXJpYWxpemU6IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG9iaiAmJiBvYmoubWVzc2FnZTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBvYmogJiYgb2JqLnN0YWNrO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqLCB7IG1lc3NhZ2UsIHN0YWNrIH0pO1xuICAgIH0sXG4gICAgZGVzZXJpYWxpemU6IChvYmopID0+IHtcbiAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihFcnJvcigpLCBvYmopO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdHJhbnNmZXJIYW5kbGVycyA9IG5ldyBNYXAoW1xuICAgIFtcIlBST1hZXCIsIHByb3h5VHJhbnNmZXJIYW5kbGVyXSxcbiAgICBbXCJUSFJPV1wiLCB0aHJvd1RyYW5zZmVySGFuZGxlcl1cbl0pO1xubGV0IHBpbmdQb25nTWVzc2FnZUNvdW50ZXIgPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIHByb3h5KGVuZHBvaW50LCB0YXJnZXQpIHtcbiAgICBpZiAoaXNXaW5kb3coZW5kcG9pbnQpKVxuICAgICAgICBlbmRwb2ludCA9IHdpbmRvd0VuZHBvaW50KGVuZHBvaW50KTtcbiAgICBpZiAoIWlzRW5kcG9pbnQoZW5kcG9pbnQpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImVuZHBvaW50IGRvZXMgbm90IGhhdmUgYWxsIG9mIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIgYW5kIHBvc3RNZXNzYWdlIGRlZmluZWRcIik7XG4gICAgYWN0aXZhdGVFbmRwb2ludChlbmRwb2ludCk7XG4gICAgcmV0dXJuIGNiUHJveHkoYXN5bmMgKGlyZXF1ZXN0KSA9PiB7XG4gICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgIGlmIChpcmVxdWVzdC50eXBlID09PSBcIkFQUExZXCIgfHwgaXJlcXVlc3QudHlwZSA9PT0gXCJDT05TVFJVQ1RcIilcbiAgICAgICAgICAgIGFyZ3MgPSBpcmVxdWVzdC5hcmd1bWVudHNMaXN0Lm1hcCh3cmFwVmFsdWUpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBpbmdQb25nTWVzc2FnZShlbmRwb2ludCwgT2JqZWN0LmFzc2lnbih7fSwgaXJlcXVlc3QsIHsgYXJndW1lbnRzTGlzdDogYXJncyB9KSwgdHJhbnNmZXJhYmxlUHJvcGVydGllcyhhcmdzKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIHJldHVybiB1bndyYXBWYWx1ZShyZXN1bHQudmFsdWUpO1xuICAgIH0sIFtdLCB0YXJnZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByb3h5VmFsdWUob2JqKSB7XG4gICAgb2JqW3Byb3h5VmFsdWVTeW1ib2xdID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9zZShyb290T2JqLCBlbmRwb2ludCkge1xuICAgIGlmIChpc1dpbmRvdyhlbmRwb2ludCkpXG4gICAgICAgIGVuZHBvaW50ID0gd2luZG93RW5kcG9pbnQoZW5kcG9pbnQpO1xuICAgIGlmICghaXNFbmRwb2ludChlbmRwb2ludCkpXG4gICAgICAgIHRocm93IEVycm9yKFwiZW5kcG9pbnQgZG9lcyBub3QgaGF2ZSBhbGwgb2YgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciBhbmQgcG9zdE1lc3NhZ2UgZGVmaW5lZFwiKTtcbiAgICBhY3RpdmF0ZUVuZHBvaW50KGVuZHBvaW50KTtcbiAgICBhdHRhY2hNZXNzYWdlSGFuZGxlcihlbmRwb2ludCwgYXN5bmMgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQuZGF0YS5pZCB8fCAhZXZlbnQuZGF0YS5jYWxsUGF0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaXJlcXVlc3QgPSBldmVudC5kYXRhO1xuICAgICAgICBsZXQgdGhhdCA9IGF3YWl0IGlyZXF1ZXN0LmNhbGxQYXRoXG4gICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAucmVkdWNlKChvYmosIHByb3BOYW1lKSA9PiBvYmpbcHJvcE5hbWVdLCByb290T2JqKTtcbiAgICAgICAgbGV0IG9iaiA9IGF3YWl0IGlyZXF1ZXN0LmNhbGxQYXRoLnJlZHVjZSgob2JqLCBwcm9wTmFtZSkgPT4gb2JqW3Byb3BOYW1lXSwgcm9vdE9iaik7XG4gICAgICAgIGxldCBpcmVzdWx0ID0gb2JqO1xuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBpZiAoaXJlcXVlc3QudHlwZSA9PT0gXCJBUFBMWVwiIHx8IGlyZXF1ZXN0LnR5cGUgPT09IFwiQ09OU1RSVUNUXCIpXG4gICAgICAgICAgICBhcmdzID0gaXJlcXVlc3QuYXJndW1lbnRzTGlzdC5tYXAodW53cmFwVmFsdWUpO1xuICAgICAgICBpZiAoaXJlcXVlc3QudHlwZSA9PT0gXCJBUFBMWVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlyZXN1bHQgPSBhd2FpdCBvYmouYXBwbHkodGhhdCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlyZXN1bHQgPSBlO1xuICAgICAgICAgICAgICAgIGlyZXN1bHRbdGhyb3dTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXJlcXVlc3QudHlwZSA9PT0gXCJDT05TVFJVQ1RcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpcmVzdWx0ID0gbmV3IG9iaiguLi5hcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgICAgaXJlc3VsdCA9IHByb3h5VmFsdWUoaXJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlyZXN1bHQgPSBlO1xuICAgICAgICAgICAgICAgIGlyZXN1bHRbdGhyb3dTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXJlcXVlc3QudHlwZSA9PT0gXCJTRVRcIikge1xuICAgICAgICAgICAgb2JqW2lyZXF1ZXN0LnByb3BlcnR5XSA9IGlyZXF1ZXN0LnZhbHVlO1xuICAgICAgICAgICAgLy8gRklYTUU6IEVTNiBQcm94eSBIYW5kbGVyIGBzZXRgIG1ldGhvZHMgYXJlIHN1cHBvc2VkIHRvIHJldHVybiBhXG4gICAgICAgICAgICAvLyBib29sZWFuLiBUbyBzaG93IGdvb2Qgd2lsbCwgd2UgcmV0dXJuIHRydWUgYXN5bmNocm9ub3VzbHkgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgIGlyZXN1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlyZXN1bHQgPSBtYWtlSW52b2NhdGlvblJlc3VsdChpcmVzdWx0KTtcbiAgICAgICAgaXJlc3VsdC5pZCA9IGlyZXF1ZXN0LmlkO1xuICAgICAgICByZXR1cm4gZW5kcG9pbnQucG9zdE1lc3NhZ2UoaXJlc3VsdCwgdHJhbnNmZXJhYmxlUHJvcGVydGllcyhbaXJlc3VsdF0pKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBWYWx1ZShhcmcpIHtcbiAgICAvLyBJcyBhcmcgaXRzZWxmIGhhbmRsZWQgYnkgYSBUcmFuc2ZlckhhbmRsZXI/XG4gICAgZm9yIChjb25zdCBba2V5LCB0cmFuc2ZlckhhbmRsZXJdIG9mIHRyYW5zZmVySGFuZGxlcnMpIHtcbiAgICAgICAgaWYgKHRyYW5zZmVySGFuZGxlci5jYW5IYW5kbGUoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYW5zZmVySGFuZGxlci5zZXJpYWxpemUoYXJnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBub3QsIHRyYXZlcnNlIHRoZSBlbnRpcmUgb2JqZWN0IGFuZCBmaW5kIGhhbmRsZWQgdmFsdWVzLlxuICAgIGxldCB3cmFwcGVkQ2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmF0ZUFsbFByb3BlcnRpZXMoYXJnKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHRyYW5zZmVySGFuZGxlcl0gb2YgdHJhbnNmZXJIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKHRyYW5zZmVySGFuZGxlci5jYW5IYW5kbGUoaXRlbS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJhbnNmZXJIYW5kbGVyLnNlcmlhbGl6ZShpdGVtLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB3cmFwcGVkQ2hpbGQgb2Ygd3JhcHBlZENoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHdyYXBwZWRDaGlsZC5wYXRoXG4gICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAucmVkdWNlKChvYmosIGtleSkgPT4gb2JqW2tleV0sIGFyZyk7XG4gICAgICAgIGNvbnRhaW5lclt3cmFwcGVkQ2hpbGQucGF0aFt3cmFwcGVkQ2hpbGQucGF0aC5sZW5ndGggLSAxXV0gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlJBV1wiLFxuICAgICAgICB2YWx1ZTogYXJnLFxuICAgICAgICB3cmFwcGVkQ2hpbGRyZW5cbiAgICB9O1xufVxuZnVuY3Rpb24gdW53cmFwVmFsdWUoYXJnKSB7XG4gICAgaWYgKHRyYW5zZmVySGFuZGxlcnMuaGFzKGFyZy50eXBlKSkge1xuICAgICAgICBjb25zdCB0cmFuc2ZlckhhbmRsZXIgPSB0cmFuc2ZlckhhbmRsZXJzLmdldChhcmcudHlwZSk7XG4gICAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXIuZGVzZXJpYWxpemUoYXJnLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSYXdXcmFwcGVkVmFsdWUoYXJnKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHdyYXBwZWRDaGlsZFZhbHVlIG9mIGFyZy53cmFwcGVkQ2hpbGRyZW4gfHwgW10pIHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmZXJIYW5kbGVycy5oYXMod3JhcHBlZENoaWxkVmFsdWUud3JhcHBlZFZhbHVlLnR5cGUpKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIHZhbHVlIHR5cGUgXCIke2FyZy50eXBlfVwiIGF0ICR7d3JhcHBlZENoaWxkVmFsdWUucGF0aC5qb2luKFwiLlwiKX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVySGFuZGxlciA9IHRyYW5zZmVySGFuZGxlcnMuZ2V0KHdyYXBwZWRDaGlsZFZhbHVlLndyYXBwZWRWYWx1ZS50eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdHJhbnNmZXJIYW5kbGVyLmRlc2VyaWFsaXplKHdyYXBwZWRDaGlsZFZhbHVlLndyYXBwZWRWYWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICByZXBsYWNlVmFsdWVJbk9iamVjdEF0UGF0aChhcmcudmFsdWUsIHdyYXBwZWRDaGlsZFZhbHVlLnBhdGgsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVua25vd24gdmFsdWUgdHlwZSBcIiR7YXJnLnR5cGV9XCJgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlVmFsdWVJbk9iamVjdEF0UGF0aChvYmosIHBhdGgsIG5ld1ZhbCkge1xuICAgIGNvbnN0IGxhc3RLZXkgPSBwYXRoLnNsaWNlKC0xKVswXTtcbiAgICBjb25zdCBsYXN0T2JqID0gcGF0aFxuICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgIC5yZWR1Y2UoKG9iaiwga2V5KSA9PiBvYmpba2V5XSwgb2JqKTtcbiAgICBsYXN0T2JqW2xhc3RLZXldID0gbmV3VmFsO1xufVxuZnVuY3Rpb24gaXNSYXdXcmFwcGVkVmFsdWUoYXJnKSB7XG4gICAgcmV0dXJuIGFyZy50eXBlID09PSBcIlJBV1wiO1xufVxuZnVuY3Rpb24gd2luZG93RW5kcG9pbnQodykge1xuICAgIGlmIChzZWxmLmNvbnN0cnVjdG9yLm5hbWUgIT09IFwiV2luZG93XCIpXG4gICAgICAgIHRocm93IEVycm9yKFwic2VsZiBpcyBub3QgYSB3aW5kb3dcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogc2VsZi5hZGRFdmVudExpc3RlbmVyLmJpbmQoc2VsZiksXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHNlbGYpLFxuICAgICAgICBwb3N0TWVzc2FnZTogKG1zZywgdHJhbnNmZXIpID0+IHcucG9zdE1lc3NhZ2UobXNnLCBcIipcIiwgdHJhbnNmZXIpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzRW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICByZXR1cm4gKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIGVuZHBvaW50ICYmXG4gICAgICAgIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIGVuZHBvaW50ICYmXG4gICAgICAgIFwicG9zdE1lc3NhZ2VcIiBpbiBlbmRwb2ludCk7XG59XG5mdW5jdGlvbiBhY3RpdmF0ZUVuZHBvaW50KGVuZHBvaW50KSB7XG4gICAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKVxuICAgICAgICBlbmRwb2ludC5zdGFydCgpO1xufVxuZnVuY3Rpb24gYXR0YWNoTWVzc2FnZUhhbmRsZXIoZW5kcG9pbnQsIGYpIHtcbiAgICAvLyBDaGVja2luZyBhbGwgcG9zc2libGUgdHlwZXMgb2YgYGVuZHBvaW50YCBtYW51YWxseSBzYXRpc2ZpZXMgVHlwZVNjcmlwdOKAmXNcbiAgICAvLyB0eXBlIGNoZWNrZXIuIE5vdCBzdXJlIHdoeSB0aGUgaW5mZXJlbmNlIGlzIGZhaWxpbmcgaGVyZS4gU2luY2UgaXTigJlzXG4gICAgLy8gdW5uZWNlc3NhcnkgY29kZSBJ4oCZbSBnb2luZyB0byByZXNvcnQgdG8gYGFueWAgZm9yIG5vdy5cbiAgICAvLyBpZihpc1dvcmtlcihlbmRwb2ludCkpXG4gICAgLy8gICBlbmRwb2ludC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZik7XG4gICAgLy8gaWYoaXNNZXNzYWdlUG9ydChlbmRwb2ludCkpXG4gICAgLy8gICBlbmRwb2ludC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZik7XG4gICAgLy8gaWYoaXNPdGhlcldpbmRvdyhlbmRwb2ludCkpXG4gICAgLy8gICBlbmRwb2ludC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZik7XG4gICAgZW5kcG9pbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZik7XG59XG5mdW5jdGlvbiBkZXRhY2hNZXNzYWdlSGFuZGxlcihlbmRwb2ludCwgZikge1xuICAgIC8vIFNhbWUgYXMgYWJvdmUuXG4gICAgZW5kcG9pbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZik7XG59XG5mdW5jdGlvbiBpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSB7XG4gICAgcmV0dXJuIGVuZHBvaW50LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTWVzc2FnZVBvcnRcIjtcbn1cbmZ1bmN0aW9uIGlzV2luZG93KGVuZHBvaW50KSB7XG4gICAgLy8gVE9ETzogVGhpcyBkb2VzbuKAmXQgd29yayBvbiBjcm9zcy1vcmlnaW4gaWZyYW1lcy5cbiAgICAvLyByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gJ1dpbmRvdyc7XG4gICAgcmV0dXJuIFtcIndpbmRvd1wiLCBcImxlbmd0aFwiLCBcImxvY2F0aW9uXCIsIFwicGFyZW50XCIsIFwib3BlbmVyXCJdLmV2ZXJ5KHByb3AgPT4gcHJvcCBpbiBlbmRwb2ludCk7XG59XG4vKipcbiAqIGBwaW5nUG9uZ01lc3NhZ2VgIHNlbmRzIGEgYHBvc3RNZXNzYWdlYCBhbmQgd2FpdHMgZm9yIGEgcmVwbHkuIFJlcGxpZXMgYXJlXG4gKiBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIGlkIHRoYXQgaXMgYXR0YWNoZWQgdG8gdGhlIHBheWxvYWQuXG4gKi9cbmZ1bmN0aW9uIHBpbmdQb25nTWVzc2FnZShlbmRwb2ludCwgbXNnLCB0cmFuc2ZlcmFibGVzKSB7XG4gICAgY29uc3QgaWQgPSBgJHt1aWR9LSR7cGluZ1BvbmdNZXNzYWdlQ291bnRlcisrfWA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBhdHRhY2hNZXNzYWdlSGFuZGxlcihlbmRwb2ludCwgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuaWQgIT09IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRldGFjaE1lc3NhZ2VIYW5kbGVyKGVuZHBvaW50LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29weSBtc2cgYW5kIGFkZCBgaWRgIHByb3BlcnR5XG4gICAgICAgIG1zZyA9IE9iamVjdC5hc3NpZ24oe30sIG1zZywgeyBpZCB9KTtcbiAgICAgICAgZW5kcG9pbnQucG9zdE1lc3NhZ2UobXNnLCB0cmFuc2ZlcmFibGVzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNiUHJveHkoY2IsIGNhbGxQYXRoID0gW10sIHRhcmdldCA9IGZ1bmN0aW9uICgpIHsgfSkge1xuICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgIGNvbnN0cnVjdChfdGFyZ2V0LCBhcmd1bWVudHNMaXN0LCBwcm94eSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkNPTlNUUlVDVFwiLFxuICAgICAgICAgICAgICAgIGNhbGxQYXRoLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c0xpc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgLy8gV2UgdXNlIGBiaW5kYCBhcyBhbiBpbmRpY2F0b3IgdG8gaGF2ZSBhIHJlbW90ZSBmdW5jdGlvbiBib3VuZCBsb2NhbGx5LlxuICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCB0YXJnZXQgZm9yIGBiaW5kKClgIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuICAgICAgICAgICAgaWYgKGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDFdID09PSBcImJpbmRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2JQcm94eShjYiwgY2FsbFBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgIHJldHVybiBjYih7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJBUFBMWVwiLFxuICAgICAgICAgICAgICAgIGNhbGxQYXRoLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c0xpc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQoX3RhcmdldCwgcHJvcGVydHksIHByb3h5KSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09IFwidGhlblwiICYmIGNhbGxQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRoZW46ICgpID0+IHByb3h5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gXCJ0aGVuXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gY2Ioe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICBjYWxsUGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocikudGhlbi5iaW5kKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiUHJveHkoY2IsIGNhbGxQYXRoLmNvbmNhdChwcm9wZXJ0eSksIF90YXJnZXRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgX3Byb3h5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2Ioe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU0VUXCIsXG4gICAgICAgICAgICAgICAgY2FsbFBhdGgsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1RyYW5zZmVyYWJsZSh0aGluZykge1xuICAgIHJldHVybiBUUkFOU0ZFUkFCTEVfVFlQRVMuc29tZSh0eXBlID0+IHRoaW5nIGluc3RhbmNlb2YgdHlwZSk7XG59XG5mdW5jdGlvbiogaXRlcmF0ZUFsbFByb3BlcnRpZXModmFsdWUsIHBhdGggPSBbXSwgdmlzaXRlZCA9IG51bGwpIHtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCF2aXNpdGVkKVxuICAgICAgICB2aXNpdGVkID0gbmV3IFdlYWtTZXQoKTtcbiAgICBpZiAodmlzaXRlZC5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHZpc2l0ZWQuYWRkKHZhbHVlKTtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHlpZWxkIHsgdmFsdWUsIHBhdGggfTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpXG4gICAgICAgIHlpZWxkKiBpdGVyYXRlQWxsUHJvcGVydGllcyh2YWx1ZVtrZXldLCBbLi4ucGF0aCwga2V5XSwgdmlzaXRlZCk7XG59XG5mdW5jdGlvbiB0cmFuc2ZlcmFibGVQcm9wZXJ0aWVzKG9iaikge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgaXRlcmF0ZUFsbFByb3BlcnRpZXMob2JqKSkge1xuICAgICAgICBpZiAoaXNUcmFuc2ZlcmFibGUocHJvcC52YWx1ZSkpXG4gICAgICAgICAgICByLnB1c2gocHJvcC52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuZnVuY3Rpb24gbWFrZUludm9jYXRpb25SZXN1bHQob2JqKSB7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgdHJhbnNmZXJIYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7XG4gICAgICAgIGlmICh0cmFuc2ZlckhhbmRsZXIuY2FuSGFuZGxlKG9iaikpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdHJhbnNmZXJIYW5kbGVyLnNlcmlhbGl6ZShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyB0eXBlLCB2YWx1ZSB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJBV1wiLFxuICAgICAgICAgICAgdmFsdWU6IG9ialxuICAgICAgICB9XG4gICAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/comlinkjs/comlink.js\n");

/***/ })

/******/ });